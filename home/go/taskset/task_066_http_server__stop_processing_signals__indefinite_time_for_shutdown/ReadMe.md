# http server : stop processing signals : indefinite time for shutdown

Our focus will be on handling SIGINT (CTRL+C) gracefully, starting an HTTP server, and then shutting it down properly upon receiving an interrupt signal.

Here's the simplified program:

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "time"
)

func run() (err error) {
    // Handle SIGINT (CTRL+C) gracefully.
    ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
    defer stop()

    // Start HTTP server.
    srv := &http.Server{
        Addr:         ":8080",
        BaseContext:  func(_ net.Listener) context.Context { return ctx },
        ReadTimeout:  1 * time.Second,
        WriteTimeout: 10 * time.Second,
        Handler:      http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            fmt.Fprintln(w, "Hello, World!")
        }),
    }
    srvErr := make(chan error, 1)
    go func() {
        fmt.Println("Server is starting on port 8080...")
        srvErr <- srv.ListenAndServe()
    }()

    // Wait for interruption or server error.
    select {
    case err = <-srvErr:
        // Error when starting or running HTTP server.
        fmt.Println("Server error:", err)
        return
    case <-ctx.Done():
        // Received SIGINT (CTRL+C).
        fmt.Println("SIGINT received, shutting down server...")
        stop()
    }

    // Attempt to gracefully shut down the server.
    if err = srv.Shutdown(context.Background()); err != nil {
        fmt.Println("Error during server shutdown:", err)
        return
    }

    fmt.Println("Server shut down gracefully.")
    return nil
}

func main() {
    if err := run(); err != nil {
        fmt.Println("Error:", err)
    }
}
```

**Explanation of Key Components:**

1. **Signal Handling for Graceful Shutdown:**
   - `ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)` creates a context that is canceled when an interrupt signal (SIGINT, typically generated by CTRL+C) is received. This allows the program to initiate a graceful shutdown process in response to such signals.
   - `defer stop()` ensures that the signal notifier is cleaned up properly, preventing resource leaks.

2. **HTTP Server Configuration and Start:**
   - The server is configured with a base context linked to the SIGINT handling, read and write timeouts to prevent hanging requests, and a simple handler that responds with "Hello, World!" to every request.
   - The server is started in a separate goroutine to allow the main goroutine to wait for a signal or an error from the server.

3. **Waiting for Interruption or Error:**
   - The `select` statement waits either for an error from the server (indicating a failure to start or a runtime error) or for a signal interrupt. This dual wait setup allows the program to respond to either event promptly.

4. **Graceful Server Shutdown:**
   - Upon receiving a SIGINT, the server attempts to shut down gracefully, allowing existing requests to complete within the configured timeouts.
   - `srv.Shutdown(context.Background())` is used to initiate the graceful shutdown. A new background context is passed to `Shutdown` since the original context (`ctx`) is already canceled by this point due to the received SIGINT.

This program demonstrates a pattern for handling interrupt signals in a Go application that includes an HTTP server, allowing for graceful shutdowns and resource cleanup. It ensures that the server can complete processing of current requests without accepting new ones, and then shuts down cleanly, providing a better experience for users and maintaining the integrity of ongoing operations.

## Here, why are we running stop() function in ctx.Done explicitly? also why pass context.Background() to srv.Shutdown? why not create a new context wich get's cacelled after 5 seconds like we did before?

Both observations point to important aspects of handling graceful shutdown in Go applications, especially regarding context management and server shutdown procedures. Let's address each question:

### 1. Why are we running `stop()` function in `ctx.Done` explicitly?

In the provided snippet, explicitly calling `stop()` after receiving a signal (detected via `ctx.Done()`) might seem redundant because the deferred call to `stop()` at the beginning should already ensure that the signal notifier is cleaned up once the function returns. However, explicitly calling `stop()` after `ctx.Done()` is triggered serves as a clear indication that signal notification should cease immediately, ensuring no further signal processing occurs as we move forward with the shutdown procedure. 

This explicit call can be seen as a best practice for immediately stopping signal listening and ensuring that the cleanup happens right away rather than waiting for the function's exit. It's more about clarity and explicitness in managing signal handling, although in this specific context, given the function's structure, it might not have a significant operational impact due to the deferred `stop()`.

### 2. Why pass `context.Background()` to `srv.Shutdown`? Why not create a new context which gets cancelled after 5 seconds like we did before?

Passing `context.Background()` to `srv.Shutdown` provides a non-timed-out context for the server shutdown process. This means the server is given as much time as it needs to shut down gracefully without the pressure of an externally imposed deadline. However, this approach might not be ideal in scenarios where the server needs to shut down within a specific timeframe, especially in managed environments or when following strict operational requirements that necessitate timely resource release.

Creating a context with a timeout (like using `context.WithTimeout`) for the server shutdown provides more control over the shutdown process, ensuring that it completes within a predefined duration. This approach prevents the server from hanging indefinitely if, for some reason, some connections don't close cleanly or if there are tasks that take too long to complete during the shutdown process.

Here's how you might modify the shutdown process to include a timeout:

```go
// Create a context for the shutdown with a 5-second timeout
shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel() // Ensure the cancel function is called to release resources

// Attempt to gracefully shut down the server with a timeout
if err := srv.Shutdown(shutdownCtx); err != nil {
    fmt.Printf("Server shutdown failed: %v\n", err)
} else {
    fmt.Println("Server shut down gracefully.")
}
```

This modification ensures that the server attempts to shut down gracefully but is also bound by a 5-second limit, providing a balance between graceful handling of active connections and adherence to operational constraints or requirements for timely shutdown.